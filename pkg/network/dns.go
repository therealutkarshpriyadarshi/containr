package network

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/therealutkarshpriyadarshi/containr/pkg/logger"
)

// DNSConfig holds DNS configuration for containers
type DNSConfig struct {
	Nameservers   []string // DNS nameserver IPs
	SearchDomains []string // DNS search domains
	Options       []string // DNS options
}

// DefaultDNSConfig returns a default DNS configuration
func DefaultDNSConfig() *DNSConfig {
	return &DNSConfig{
		Nameservers: []string{
			"8.8.8.8",       // Google DNS
			"8.8.4.4",       // Google DNS secondary
			"1.1.1.1",       // Cloudflare DNS
		},
		SearchDomains: []string{},
		Options:       []string{"ndots:0"},
	}
}

// GenerateResolvConf generates the content for /etc/resolv.conf
func (d *DNSConfig) GenerateResolvConf() string {
	content := "# Generated by containr\n"

	// Add search domains
	if len(d.SearchDomains) > 0 {
		content += "search"
		for _, domain := range d.SearchDomains {
			content += " " + domain
		}
		content += "\n"
	}

	// Add nameservers
	for _, ns := range d.Nameservers {
		content += fmt.Sprintf("nameserver %s\n", ns)
	}

	// Add options
	if len(d.Options) > 0 {
		content += "options"
		for _, opt := range d.Options {
			content += " " + opt
		}
		content += "\n"
	}

	return content
}

// SetupDNS configures DNS for a container
func SetupDNS(rootPath string, config *DNSConfig) error {
	log := logger.New("dns")

	if config == nil {
		config = DefaultDNSConfig()
	}

	log.Debug("Setting up DNS configuration")

	// Generate resolv.conf content
	content := config.GenerateResolvConf()

	// Create /etc directory if it doesn't exist
	etcDir := filepath.Join(rootPath, "etc")
	if err := os.MkdirAll(etcDir, 0755); err != nil {
		return fmt.Errorf("failed to create /etc directory: %w", err)
	}

	// Write resolv.conf
	resolvPath := filepath.Join(etcDir, "resolv.conf")
	if err := os.WriteFile(resolvPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write resolv.conf: %w", err)
	}

	log.Debugf("DNS configuration written to %s", resolvPath)
	log.Debugf("Nameservers: %v", config.Nameservers)

	return nil
}

// SetupHostsFile creates a basic /etc/hosts file for the container
func SetupHostsFile(rootPath, hostname, containerIP string) error {
	log := logger.New("dns")

	log.Debug("Setting up hosts file")

	// Create /etc directory if it doesn't exist
	etcDir := filepath.Join(rootPath, "etc")
	if err := os.MkdirAll(etcDir, 0755); err != nil {
		return fmt.Errorf("failed to create /etc directory: %w", err)
	}

	// Generate hosts file content
	content := fmt.Sprintf(`# Generated by containr
127.0.0.1	localhost
::1		localhost ip6-localhost ip6-loopback
fe00::0		ip6-localnet
ff00::0		ip6-mcastprefix
ff02::1		ip6-allnodes
ff02::2		ip6-allrouters
%s		%s
`, containerIP, hostname)

	// Write hosts file
	hostsPath := filepath.Join(etcDir, "hosts")
	if err := os.WriteFile(hostsPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write hosts file: %w", err)
	}

	log.Debugf("Hosts file written to %s", hostsPath)
	return nil
}

// SetupHostname sets the container hostname
func SetupHostname(rootPath, hostname string) error {
	log := logger.New("dns")

	log.Debugf("Setting up hostname: %s", hostname)

	// Create /etc directory if it doesn't exist
	etcDir := filepath.Join(rootPath, "etc")
	if err := os.MkdirAll(etcDir, 0755); err != nil {
		return fmt.Errorf("failed to create /etc directory: %w", err)
	}

	// Write hostname file
	hostnamePath := filepath.Join(etcDir, "hostname")
	if err := os.WriteFile(hostnamePath, []byte(hostname+"\n"), 0644); err != nil {
		return fmt.Errorf("failed to write hostname file: %w", err)
	}

	log.Debugf("Hostname file written to %s", hostnamePath)
	return nil
}
